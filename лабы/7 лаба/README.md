Лабораторная работа №7  Работа с классами ч.3

Цель работы: Разработать систему управления сотрудниками, демонстрирующую множественное наследование, инкапсуляцию и полиморфизм в Python. Система должна уметь обрабатывать различные типы сотрудников, включая менеджеров и технических специалистов, а также предоставлять возможность для расширения и добавления новых ролей.

Задание

1.	Создайте класс Employee с общими атрибутами, такими как name (имя), id (идентификационный номер) и методами, например, get_info(), который возвращает базовую информацию о сотруднике. Реализуем создание атрибута имени и присваивание ему значения в инициализации, а атрибут индикатора (id) создадим перед инициализацией, сделав это атрибутом всего класса (присвоим ему значение 0). Затем, в инициализации создадим id объекта и приравняем его к значению атрибута класса. Атрибут класса затем увеличим на единичку, т.е id каждого объекта будет считаться автоматически.  Вывод информации о сотруднике реализуем с помощью f-строки.  
2.	Создайте класс Manager с дополнительными атрибутами, такими как department (отдел) и методами, например, manage_project(), символизирующим управление проектами. 
3.	Создайте класс Technician с уникальными атрибутами, такими как specialization (специализация), и методами, например, perform_maintenance(), означающим выполнение технического обслуживания.
4.	Создайте класс TechManager, который наследует как Manager, так и Technician. Этот класс должен комбинировать управленческие способности и технические навыки, например, иметь методы для управления проектами и выполнения технического обслуживания.
5.	Добавьте метод add_employee(), который позволяет TechManager добавлять сотрудников в список подчинённых.
6.	Реализуйте метод get_team_info(), который выводит информацию о всех подчинённых сотрудниках.

Для реализации более сложных родительский и дочерних классов реализуем передачу аргументов в инициализацию с помощью kwargs – параметров. Для этого сделаем все аргументы именованными – name, department (для Manager и TechManager) и specialization (для Technician и TechManager), тогда нужные параметры будем передавать именованными аргументами, а ненужные – в составе kwargs. Каждому из дочерних классов добавим атрибут – должность. В инициализации дочерних классов будем использовать метод super с использованием именованных аргументов и kwargs (так как у класса TechManager два родителя с разными атрибутами). (Метод супер выполняет указанный метод внутри родительского класса, после этого мы дообъявляем атрибуты дочернего класса и присваиваем им значения). 
Добавим общий метод смены имени (определим только в родительском классе, далее он не будет требовать изменений) и метод вывода информации: его определим в родительском классе и переопределим для всех остальных (так как меняются аргументы). 

Manager: реализуем метод manage_project(name, project_id, priority), для этого добавим атрибут объекта – projects – список проектов, состоящий из кортежа (индификатор_проекта, название, приоритет). В методе manage_project реализуем добавление нового проекта с указанными характеристиками в общий массив. Добавим метод projects_info(), который выводит информацию о всех проектах работника в виде «project_id: {id}, {name}, the priority is {…}»

Technician: реализуем метод perform_maintenance(object, period, requirement), для этого добавим атрибут объекта – contracts – список контрактов, состоящий из массива (объект, период, требования). В методе perform_maintenance реализуем добавление нового контракта с указанными характеристиками в общий массив. Добавим метод contracts_info (), который выводит информацию о всех проектах работника в виде «обслуживание {object}, for {period}, the requirement is {…}»

TechManager: добавим атрибут объекта – список подчиненных (массив из объектов класса Employee и дочерних). В методе add_employee(employee) реализуем добавление сотрудника в список подчиненных. В методе get_team_info реализуем вывод информации о каждом сотруднике (для этого пройдемся циклом по списку подчиненных и для каждого вызовем метод get_info (определенный для каждого класса по-своему)

7.	Создайте объекты каждого класса и демонстрируйте их функциональность.



